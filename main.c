#define _POSIX_C_SOURCE 200809L

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <stdbool.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>
#include <semaphore.h>

//
// Citation: some code adapted from course's sample code
// https://repl.it/@cs344/65prodconspipelinec
//

//
// Sizes of the buffer_1 and buffer_2 arrays
//		Both have MAX_LINES number of arrays
//		of size BUF_SIZE
//
#define BUF_SIZE 1000
#define MAX_LINES 50

//
// Size of the buffer_3 arrays
//		It has MAX_PRINT_LINES number of arrays
//		of size PRINT_SIZE
//
#define PRINT_SIZE 80
#define MAX_PRINT_LINES 650

//
// BUFFERS
// 
// buffer_1 holds chars read from stdin
// 
//		generated by input()
//		passed to line()
//
// buffer_2 holds chars read from buffer_1 with newline 
//		characters replaced by spaces
// 
//		generated by line()
//		passed to plus()
//
// buffer_3 holds chars read from buffer_2 with pairs
//		of plus signs replaced by carats
//		ie. "+++++" = "^^+"
// 
//		generated by plus()
//		passed to output()
//		output() then prints in 80 character increments
//
//		NOTE: the size of each array in buffer_3 differs 
//		from buffer_1 and buffer_2. buffer_1 and buffer_2 
//		are 1000 char each. buffer_3 is 80 characters
//		each to prepare for printing format
//
char buffer_1[MAX_LINES][BUF_SIZE];
char buffer_2[MAX_LINES][BUF_SIZE];
char buffer_3[MAX_PRINT_LINES][PRINT_SIZE];

//
// Global Variables:
//		stop_found is true if "STOP\n" is read from stdin
//			it indicates that each thread's while loop 
//			should break and the program should exit
// 
//		lines_read indicates buffer_1's line index
// 
//		char_read indicates the number of characters read
//			by input() that have YET to be printed.
//			Thus, if char_read == 90 when input() passes
//			off buffer_1, when output() finishes printing
//			in 80-character increments, it will alter
//			char_read so that char_read == 10
// 
//		okay_to_exit is a basic counter that ensures that
//			no process will exit until the others are 
//			ready. ie., when a thread is done and ready
//			to terminate, it does the following:
//				okay_to_exit++;
//				while (okay_to_exit < 4) {}
//			
//			With the return NULL; call following the 
//			while loop, no thread can prematurely 
//			terminate.
// 
bool stop_found = false;
int lines_read = 0;
int char_read = 0;
int okay_to_exit = 0;

//
// Declare the mutex for buffer passing
//		mutex_1 initialized in main()
pthread_mutex_t mutex_1;

//
// Declare the condition variables for buffer passing
//		CVs initialized in main()
pthread_cond_t line_permitted;
pthread_cond_t plus_permitted;
pthread_cond_t buf_full;
pthread_cond_t buf_empty;

//
// Booleans to ensure each thread's while loop containing
//		pthread_cond_wait() is entered and exited at with
//		the appropriate timing.
// 
bool input_wait = false;
bool line_wait = true;
bool plus_wait = true;
bool output_wait = true;
// pthread_cond_t okay_to_exit;

//
// create:
//		thr_input to read data from stdin
//		thr_line to handle newline characters
//		thr_plus to handle pairs of plus signs
//		thr_output to write altered data to stdout
pthread_t thr_input, thr_line, thr_plus, thr_output;

//
// 
// input() is called in main by pthread_create(&thr_input, NULL, &input, NULL);
// 
//		input() is utilized to process text from stdin.
// 
//		After locking mutex_1, input() reads text from stdin into buffer_1.
//		
//		Once input() has at least 80 characters that have yet to be printed in
//		buffer_1, it signals to line() and unlocks mutex_1.
// 
//
void *input(void *arg) 
{
	char stop[5] = "STOP\n";

	// begin while loop which can only end by break; which occurs
	//		if stop_found = true
	while (!stop_found) {
		
		// Lock the mutex before putting the item in the buffer
		pthread_mutex_lock(&mutex_1);

		// bool input_wait gives us control over when the thread enters
		//		and exits the while loop containing pthread_cond_wait
		while (input_wait) {
			// if input_wait == true: wait for the condition variable
			//		buf_empty from output()
			pthread_cond_wait(&buf_empty, &mutex_1);
		}

		if (stop_found) {
			break;
		}

		// text should be printed once the buffer holds at least
		//		80 characters
		while (char_read < 80) {
			fgets(buffer_1[lines_read], BUF_SIZE, stdin);
			
			// check for STOP
			if (strcmp(buffer_1[lines_read], stop) == 0) {
				stop_found = true;
				break;
			}

			// update char_read and lines_read after reading from stdin
			char_read = char_read + strlen(buffer_1[lines_read]);
			lines_read++;
		}

		// update bools
		input_wait = true;
		line_wait = false;

		// signal line() and unlock mutex
		pthread_cond_signal(&line_permitted);
		pthread_mutex_unlock(&mutex_1);
	}

	okay_to_exit++;

	while (okay_to_exit < 4) {
		// waiting for all threads
	}

	return NULL;
}

//
// 
// line() is called in main by pthread_create(&thr_line, NULL, &line, NULL);
// 
//		line() is utilized to process text from buffer_1.
// 
//		After locking mutex_1, line() reads text from buffer_1, replaces any
//		newline characters with spaces, and copies the edited text into 
//		buffer_2.
//		
//		Once line() has processed all of buffer_1, it signals to plus() and 
//		unlocks mutex_1.
// 
//
void* line(void* arg) {

	int buf_1_char_index = 0;
	int buf_1_string_index = 0;
	int i = 0;
	int	cur_str_len = 0;

	while (!stop_found) {

		if (stop_found) {
			break;
		}

		pthread_mutex_lock(&mutex_1);

		while (line_wait) {
			// if line_wait == true: wait for the condition variable
			//		line_permitted from input()
			pthread_cond_wait(&line_permitted, &mutex_1);
		}

		i = 0;

		while (i < char_read) {

			cur_str_len = strlen(buffer_1[buf_1_string_index]);

			while (buf_1_char_index < cur_str_len) {

				if (buffer_1[buf_1_string_index][buf_1_char_index] == '\n')
				{
					buffer_2[buf_1_string_index][buf_1_char_index] = ' ';
				}
				else {
					buffer_2[buf_1_string_index][buf_1_char_index] = 
						buffer_1[buf_1_string_index][buf_1_char_index];
				}
				buf_1_char_index++;
				i++;
			}
			if (strlen(buffer_1[buf_1_string_index + 1]) != 0) {
				buf_1_char_index = 0;
				buf_1_string_index++;
			}
			else {
				break;
			}
		}
		
		// update bools
		line_wait = true;
		plus_wait = false;

		// signal plus() and unlock mutex
		pthread_cond_signal(&plus_permitted);
		pthread_mutex_unlock(&mutex_1);
	}

	okay_to_exit++;

	while (okay_to_exit < 4) {
		// waiting for all threads
	}

	return NULL;
}

//
// 
// plus() is called in main by pthread_create(&thr_plus, NULL, &plus, NULL);
// 
//		plus() is utilized to process text from buffer_2
// 
//		After locking mutex_1, plus() reads text from buffer_2, replaces all 
//		pairs of plus signs with carats, and copies the edited text into
//		buffer_2. 
// 
//		e.g. "+++++" == "^^+"
//		
//		Once plus() has processed all of buffer_2, it signals to plus() and 
//		unlocks mutex_1
// 
//
void* plus(void* arg) {

	// local counter variables
	int i = 0;
	int buf_2_string_index = 0;
	int buf_2_char_index = 0;
	int buf_3_string_index = 0;
	int buf_3_char_index = 0;
	int	cur_str_len = 0;

	while (!stop_found) {

		if (stop_found) {
			break;
		}

		pthread_mutex_lock(&mutex_1);

		while (plus_wait) {
			// if plus_wait == true: wait for the condition variable
			//		plus_permitted from line()
			pthread_cond_wait(&plus_permitted, &mutex_1);
		}

		i = 0;
		while (i < char_read) {
			cur_str_len = strlen(buffer_2[buf_2_string_index]);

			while (buf_2_char_index < cur_str_len) {
				/*if (buffer_2[m][n] == '\0') {
					n = 0;
					m++;
				}*/

				if (buffer_2[buf_2_string_index][buf_2_char_index] == '+') {
					if (buffer_2[buf_2_string_index][buf_2_char_index + 1] == '+') {
						buffer_3[buf_3_string_index][buf_3_char_index] = '^';

						buf_2_char_index++;

						// because we effectively 'remove' one char in the transfer, we
						//		need to decrement the main count of chars to be printed
						char_read--;
						cur_str_len--;
					}
				}
				else {
					buffer_3[buf_3_string_index][buf_3_char_index] = 
						buffer_2[buf_2_string_index][buf_2_char_index];
				}

				if (buf_3_char_index == 79) {
					buf_3_char_index = 0;
					buf_3_string_index++;
				}
				else {
					buf_3_char_index++;
				}

				buf_2_char_index++;
				i++;
			}

			if (strlen(buffer_2[buf_2_string_index + 1]) != 0) {
				buf_2_char_index = 0;
				buf_2_string_index++;
			}
			else {
				break;
			}
		}

		// update bools
		plus_wait = true;
		output_wait = false;

		// signal output() and unlock mutex
		pthread_cond_signal(&buf_full);
		pthread_mutex_unlock(&mutex_1);
	}

	okay_to_exit++;

	while (okay_to_exit < 4) {
		// waiting for all threads
	}

	return NULL;
}

//
// 
// output() is called in main by pthread_create(&thr_output, NULL, &output, NULL);
// 
//		output() is utilized to print text from buffer_3 according to the 
//		80-character formatting restriction.
// 
//		After locking mutex_1, output() reads text from buffer_3 and prints lines
//		of text 80 characters, plus newline, at a time. 
// 
//		Once output() reachces a line in buffer_3 consisting of fewer than 80 
//		characters, it updates char_read such that:
//			char_read = char_read - char_printed;
//		and then signals to input() and unlocks mutex_1.
// 
//
void* output(void* arg) {

	// local counter variables
	int char_remaining = 0;
	int char_printed = 0;
	int buf_3_string_index = 0;
	int buf_3_char_index = 0;
	int	cur_str_len = 0;

	while (!stop_found)
	{

		if (stop_found) {
			break;
		}

		pthread_mutex_lock(&mutex_1);

		while (output_wait) {
			// if output_wait == true: wait for the condition variable
			//		buf_full from plus()
			pthread_cond_wait(&buf_full, &mutex_1);
		}

		// update char_printed and char_remaining to reflect updated
		//		values from input()
		char_printed = 0;
		char_remaining = char_read;

		//
		// Printing Statement
		// 
		// this while condition may seem convoluted, but it's basically saying
		//		as long as we have enough characters remaining to fill another 80-char
		//		line, keep processing
		while ((char_remaining > (80 - (char_printed % 80)))) {
			printf("%c", buffer_3[buf_3_string_index][buf_3_char_index]);
			fflush(stdout);

			char_remaining--;
			char_printed++;

			if (buf_3_char_index == 79) {
				buf_3_char_index = 0;
				buf_3_string_index++;

				// if end of string array, it means we've printed 80 chars,
				//		which should always be followed by '\n'
				printf("\n");
				fflush(stdout);
			}

			else {
				buf_3_char_index++;
			}
		}

		// update char_read to reflect the number of characters read from
		//		input, but still yet not printed
		char_read = char_read - char_printed;

		// update bools
		output_wait = true;
		input_wait = false;

		// signal first thread and unlock mutex
		pthread_cond_signal(&buf_empty);
		pthread_mutex_unlock(&mutex_1);
	}

	okay_to_exit++;

	while (okay_to_exit < 4) {
		// waiting for all threads
	}

	return NULL;
}

int main()
{
	// initialize pthread conditions
	pthread_cond_init(&buf_full, NULL);
	pthread_cond_init(&buf_empty, NULL);
	pthread_cond_init(&line_permitted, NULL);
	pthread_cond_init(&plus_permitted, NULL);

	// initialize pthread mutex
	pthread_mutex_init(&mutex_1, NULL);

	// Create threads
	pthread_create(&thr_input, NULL, &input, NULL);
	pthread_create(&thr_line, NULL, &line, NULL);
	pthread_create(&thr_plus, NULL, &plus, NULL);
	pthread_create(&thr_output, NULL, &output, NULL);

	// Wait for the threads to terminate
	pthread_join(thr_input, NULL);
	pthread_join(thr_line, NULL);
	pthread_join(thr_plus, NULL);
	pthread_join(thr_output, NULL);

	pthread_mutex_destroy(&mutex_1);
	
	exit(0);
}
